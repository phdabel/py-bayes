Na criptografia, Blowfish é uma cifra simétrica de blocos que pode ser usado em substituição ao DES ou IDEA. Ele toma uma chave de tamanho variável, de 32 a 448 bits, tornando-o ideal para aplicações tanto domésticas, quanto comerciais. O Blowfish foi desenvolvido em 1993 por Bruce Schneier como uma alternativa grátis mais rápida para os algorítmos criptográficos existentes. Desde então ele vem sendo analisado de forma considerável e está conquistando a aceitação do mercado como um algoritmo forte. O Blowfish não é patenteado, tem sua licença grátis e está a disposição para todos.O artigo original do Blowfish foi apresentado no "First Fast Software Encryption Workshop" ocorrido em Cambridge, MA, EUA. Os resultados do workshop foram publicados por Springer-Verlanf, "Lecture Notes in Computer Science" #809, 1994). A edição de abril de 1994 de "Dr. Dobb's Journal" também tratou expôs a proposta de Bruce Schneier. "Blowfish -- One Year Later" foi publicada em Setembro de 1995 em outra edição de "Dr. Dobb's Journal".Muitos estudiosos em criptografia examinaram o Blowfish, entretanto, ainda são poucos os resultados publicados. Serge Vaudenay examinou chaves fracas no Blowfish: existe uma classe de chaves que podem ser detectadas - mas não "quebradas" - no Blowfish com variantes de 14 iterações ou menos.Qualquer pessoa pode obter uma cópia do código-fonte do Blowfish a partir da Internet e fazer uso em suas aplicações. Não há regras de uso do código. Bruce Schneier pede, somente, que seja notificado de aplicações comerciais para que possam ser listadas em sua página na Internet.A criptografia é feita através de uma função com 16 iterações. Apesar do complexo algoritmo de inicialização, o Blowfish tem grande eficiência com os microprocessadores atuais. A cifragem do texto é feita em blocos de 64 ou 128 bits, nos quais os bits não são tratados separadamente, mas em grupos de 32 bits. A fim de aumentar sua eficiência, foi escolhido usar na confecção deste algoritmo funções simples para os microprocessadores, tais como XOR, adição e multiplicação modular. O algoritmo consiste de duas partes, sendo elas a expansão da chave e a criptografia dos dados. A primeira consiste na transformação da chave em subchaves, totalizando 4168 bits. A segunda consiste de 16 fases, sendo que, em cada uma dessas, é feita uma permutação dependente da chave e uma substituição dependente da chave e dos dados.A matriz P consiste de 18 subchaves de 32 bits, com seus elementos variando de P1 ate P18. Utilizam-se também 4 S-Boxes, cada uma constituída de 256 elementos de 32 bits cada. Inicialmente, as S-boxes são preenchidas com os dígitos hexadecimais de Pi, exceto o dígito inicial 3. O bit mais significativo da fração de Pi se torna o mais significativo da primeira subchave. Como exemplo:Em seguida, faz-se um XOR entre os 32 primeiros bits da chave com P1, os próximos 32 bits da chave com P2, e assim por diante, até P14. Caso os bits da chave cheguem ao fim antes de P14, então se deve repeti-los até o fim da matriz.Após isso, usando-se uma cadeia de caracteres de constituída apenas por zeros, executa-se o algoritmo usando as sub-chaves já criadas. O resultado desse processo deve ser armazenado em P1 e P2, e em seguida servirá de entrada para o algoritmo novamente. Esse novo produto será armazenado em P3 e P4, e servirá mais uma vez de entrada, ate que sejam preenchidas todas as subchaves e S-boxes.No total, serão feitas 512 iterações apenas para gerar as sub-chaves. A fim de tornar a utilização do algoritmo mais simples, é sugerido que os aplicativos guardem essas sub-chaves geradas, ao invés de fazer esse complexo processo múltiplas vezes.A entrada para essa parte do algoritmo são 64 bits, que serão divididos em dois grupos de 32 bits, que serão chamados de xL e xR. As operações abaixo deverão ser feitas 16 vezes.Após a décima sexta iteração, é necessário trocar xL e xR mais uma vez (troca de xL e xR). Em seguida, são feitas as seguintes operações:O texto cifrado será a união desses dois grupos (xLxR). A função F segue os seguintes passos:O processo de obtenção do texto original a partir do cifrado é feito da mesma forma, porém utilizando a matriz P em ordem inversa.Blowfish é uma das cifras mais rápidas em uso, exceto ao mudar chaves. Cada chave nova requer o pre-processamento equivalente a encriptação de aproximadamente 4 kilobytes do texto, o que é muito lento se comparado a outras cifras. Isto impede seu uso em determinadas aplicações, mas não é um problema em outras. Em algumas aplicações é realmente um benefício: o método da troca de senha usado em OpenBSD usa um algoritmo derivado de Blowfish que emprega a programação de chave lenta;  a ideia é que o esforço computacional extra requerido dá a proteção de encontro aos ataques de dicionário. Em algumas execuções, Blowfish tem uma exigência relativamente grande da memória (acima de 4 kilobytes). Este não é um problema mesmo para computadores menores e mais velhos ou laptops, mas impede o uso em sistemas menores tais como smartcards.